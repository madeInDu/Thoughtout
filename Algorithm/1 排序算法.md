# 排序算法

### 1.1 快速排序

题目链接：

- 快速排序：https://www.acwing.com/activity/content/problem/content/819/
- 第 k 个数：https://www.acwing.com/activity/content/problem/content/820/

**基本思想：**

​	采用”分治“的思想：

​		对于一组数据，选择一个基准元素，通常**选择第一个**或者**最后一个**；

​		通过第一轮扫描**比 base 小的元素都在 base 的左边**，**比 base 大的元素都在 base 的右边**；

​		再用同样的方法递归排序这两部分，知道序列中所有的元素均有序为止。

<img src="C:\Users\Administrator\Desktop\图片存储\typo\基本算法\快速排序.png" alt="快速排序" style="zoom:67%;" />

```c++
void quick_sort(int q[], int l, int r)
{
    if (l >= r) return;

    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while (i < j)
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```

--------------------------------------------------------------

### 1.2 归并排序 

题目链接

- 归并排序：https://www.acwing.com/problem/content/789/
- 逆序对的数量：https://www.acwing.com/problem/content/790/

**定义**

- 归并排序是建立在归并操作上的一种有效的排序算法， 采用分治法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。

**算法思路**

- **分**：把原数组划分为两个子数组的过程

- **治**：将两个有序数组合并成一个更大的有序数组

  - 将待排序的线性表不断切分为若干个子表，直到每个子表只含有一个元素，此时，可以认为只包含一个元素的子表是有序表。
  - 将子表两两合并，每合并一次，就会产生一个新的且更长的有序表，重复这一步骤，直到最后只剩下一个子表，这个子表就是排好序的线性表。
  - 图解分析：
    - 假设初始数组为{8,4,5,7,1,3,6,2}
    - ![img](https://i-blog.csdnimg.cn/blog_migrate/79510ba165786116c3a394cf6c4ee6f9.png)
    - 可以看到这种结构很像一棵完全二叉树，我们采用递归去实现（也可采用迭代的方式去实现）。**分**阶段可以理解为就是递归拆分子序列的过程，递归深度为log2n。
  - **合并两个有序数组流程**
    - 再来看看**治**阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤。
    - ![img](https://i-blog.csdnimg.cn/blog_migrate/76d1b7becae2df55951ab995cb693bdd.png)
  - **动画展示**
    - ![img](https://i-blog.csdnimg.cn/blog_migrate/1c9517428afa0244546c0e08a8e7c3fe.gif)
  - **算法性能**
    - 仅次于快速排序
  - **时间复杂度**
    - O(nlogn)
  - **空间复杂度**
    - O(N)
  - **稳定性**
    - 稳定

- 代码实现：

  - ```c++
    void merge_sort(int q[],int l,int r){
        if(l > r) return;
        int mid = l + r >> 1;
        merge_sort(q,l,mid);
        merge_sort(q,mid+1,r);
        
        int k = 0,l = 1,j = mid + 1;
        while(i <= mid && j <= r){
    		if (q[i] <= q[j]) tmp[k ++ ] = q[i ++ ];
            	else tmp[k ++ ] = q[j ++ ];
        }
    
        while (i <= mid) tmp[k ++ ] = q[i ++ ];
        while (j <= r) tmp[k ++ ] = q[j ++ ];
    
        for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
    }
    ```

  - ```java
    
    ```

    

